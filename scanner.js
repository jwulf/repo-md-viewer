// Written against node v0.8.11// This is a metadata extractor for brew tags// Given a brew tag, it will extract the Group and Description metadata// from the packages in that tag// and store this information in a MongoDB Databasevar xmlrpc = require('xmlrpc');var program = require('commander');var async = require('async');var url = require('url');var exec = require ('child_process').exec;var fs = require('fs');var mongoose = require('mongoose'), db = mongoose.createConnection('localhost', 'pkgMetadata');var latestPackages = [];var tag;var startTime, dbConnected;var downloadDir = '/tmp/node-metadata/download';var cacheDir = '/tmp/node-metadata/cache';var packagesToDownload, packagesDownloaded;var cacheHits = 0;var downloads = 0;var brewCacheHit = false;var brewTag;// MongoDB Schema definition for the Mongoose ORMvar pkgMetadataSchema = new mongoose.Schema({    pkgName: String,    pkgVersion: String,    nvr: String,    brewtags: [{tag: String}],    build_id: Number,    owner_name: String,    rpmurl: String,    group: String,    description: String,    scanDate: Date  },  {collection: 'BrewPkgMetadata'});// Database indicespkgMetadataSchema.index({pkgName: 1});pkgMetadataSchema.index({pkgName:1, pkgVersion: 1});pkgMetadataSchema.index({group: 1});pkgMetadataSchema.index({brewtags: 1});var PkgMetadata = db.model('PkgMetadata', pkgMetadataSchema);// Brew tag metadata storage supportvar brewTagMetadataSchema = new mongoose.Schema({    tagName: String,    pkgList: [{              pkgName: String,               nvr: String,               rpmurl: String,               build_id: Number,               owner_name: String,              pkgVersion: String            }]  },  {collection: 'BrewTagMetadata'});var BrewTagMetadata = db.model('BrewTagMetadata', brewTagMetadataSchema);db.on('error', function(){console.error.bind(console, 'connection error:'); dbConnected = false; console.log('WARNING: This scan will not update the local database');});db.on('open', function () {  dbConnected = true;  //console.log('Connected to local database.')});// Queue for limiting concurrent download processes // Called with wget as the command from downloadRPM// Metadata extraction is also rate limited via this queue,// as it is hooked into the callback function for downloaded packagesvar q = async.queue(function(task, cb){  debug('Started: ' + task.command);  debug('Processes: ' + q.length());  console.log('Downloading rpm package ' + task.rpmfilename);  exec(task.command, {maxBuffer: 400*1024}, function(err, stdout, stderr) {    debug('wget completed');    if (err) {console.log(stdout); console.log(stderr); throw err;}    debug('Completed: ' + task.command);    downloads++;    cb();       })}, 10);// This queue rate limits metadata extraction from cached rpms// Working against a large cache of downloaded rpms, // the extractor can spin up a lot of tasks in parallelvar q2 = async.queue(function(task,cb){  stripMetadata(task.item, task.rpmfile, cb);}, 10);program  .version('0.0.1')  .option('-c, --cache', 'use cached rpm packages when available, update the local cache when not')  .option('-d, --debug', 'emit verbose messages for debugging')  .option('-m, --metadatacache', 'use cached brew tag and package metadata')  .option('-u, --updatecache', 'use the network, and update (refresh) the local cache')  .option('-t, --tag <brew tag>', 'supply a brew tag to scan', String)  .option('-s, --server <url>', 'specify server to scan', String)  .parse(process.argv);if (program.metadatacache) console.log('Using available local brew metadata cache');if (program.cache) console.log('Using available local rpm cache ' + cacheDir);if (program.cache || program.updatecache) console.log('Caching rpm downloads to ' + cacheDir);// Recursive directory creation function, analogous to mkdir -pfs.mkdirParentSync = function(dirPath, mode, callback) {  //Call the standard fs.mkdirSync  fs.mkdirSync(dirPath, mode, function(error) {    //When it fail in this way, do the custom steps    if (error && error.errno === 34) {      //Create all the parents recursively      fs.mkdirParent(path.dirname(dirPath), mode, callback);      //And then the directory      fs.mkdirParent(dirPath, mode, callback);    }    //Manually run the callback since we used our own callback to do all these    callback && callback(error);  });}// Create our download and cache directories if they don't already existif (!fs.existsSync(cacheDir)) fs.mkdirParentSync(cacheDir);if (!fs.existsSync(downloadDir)) fs.mkdirParentSync(downloadDir);// If called with a tag from the command line// Start straight awayif (program.tag) {  tag = program.tag;  doBrewScan();}else{  // otherwise, prompt for a tag  program.prompt('Enter a brew tag name (default: ' + tag + '): ', function(response){    if (response) tag = response;    doBrewScan();  });}function doBrewScan(){  startTime = new Date().getTime();         console.log('Scanning Brew tag: ' + tag);    // if we were started with the -m or --metadatacache switch  // Try to pull the brew metadata from the database  if (program.metadatacache)  {    hitMetadataCache(tag);  }  else  {    // otherwise, go straight to Brew's XML RPC interface    hitUpBrew(tag);  }}function hitMetadataCache(tag){    BrewTagMetadata.find({tagName: tag}, function(err, docs){      if (docs.length === 0)      {        console.log('No local metadata available for tag ' + tag);        hitUpBrew(tag);      }      else      {        brewTag = docs[0];        console.log('Found ' + brewTag.pkgList.length + ' packages listed in local metadata cache for ' + brewTag.tagName);        debug('Populating package list from metadata cache');        brewTag.pkgList.forEach(function(p, array, index){          var pkgMetadataEntry = new PkgMetadata({              'pkgName': p.pkgName,               'nvr': p.nvr,               'brewtags': [{'tag': tag}],               'scanDate': startTime,              'owner_name': p.owner_name,              'build_id': p.build_id,              'rpmurl': p.rpmurl,              'pkgVersion': p.pkgVersion            });          latestPackages.push(pkgMetadataEntry);        });        brewCacheHit = true;        getRPMs(null, latestPackages);      }    });}function hitUpBrew(tag){  console.log('Retrieving ID for brew tag %s', tag);  getTagID(tag, function(tagID){    console.log('TagID is %s', tagID);    getPackageList(tag, tagID, processPackageList);  });  // Pull the brew tag metadata record from the db  // If we find one, zero the package list  // If not, create a new one with an empty package list  // The brew tag metadata will be updated as a side effect of the scan  BrewTagMetadata.find({tagName: tag}, function(err, docs){    if (docs.length === 0) {      brewTag = new BrewTagMetadata({tagName: tag, pkgList: []});    }    else    {      brewTag = docs[0];      brewTag.pkgList = [];      brewTag.markModified('pkgList');    }  });}function debug(msg){  if (program.debug) console.log('DEBUG: ' + msg);}function getTagID(tagName, callback){  var client = xmlrpc.createClient({ host:  'brewhub.devel.redhat.com', port: 80, path: '/brewhub'});  console.log('Retrieving Tag ID from brew...');  client.methodCall('getTag', [tagName], function (error, value){    callback(value['id']);  });}function getPackageList(tag, tagID, callback){  var client = xmlrpc.createClient({ host:  'brewhub.devel.redhat.com', port: 80, path: '/brewhub'});  console.log('Retrieving package list for tag ' + tag);  client.methodCall('listPackages', [tagID], function (error, value){    callback(tag, tagID, value);  });}function processPackageList(tag, tagID, packageList){// We get a list of package objects for the tag, and we will construct a list of latest builds// Using push to construct an array, rather than async.map, as there may well be less builds than// packages  console.log('Retrieved ' + packageList.length + ' packages for tag ' + tag);   console.log('Retrieving latest builds list...');    function getLatestBuild(pkg, cb){    var packageName = pkg['package_name'];    var client = xmlrpc.createClient({ host:  'brewhub.devel.redhat.com', port: 80, path: '/brewhub'});    client.methodCall('getLatestBuilds', [tag, {'__starstar': 1, 'package': packageName}], function (error, value){      if (!error){        if (value.length == 1){          var pkgMetadataEntry = new PkgMetadata({              'pkgName': packageName,               'nvr': value[0]['nvr'],               'brewtags': [{'tag': tag}],               'scanDate': startTime            });          latestPackages.push(pkgMetadataEntry);        }      }      else      {         console.log(error);      }      cb();    });  }  async.forEach(packageList, getLatestBuild, function(err){getBuilds()});    }function getBuilds(){  // latestPackages is an array of objects in the form {pkgName, nvr}  console.log('Retrieved ' + latestPackages.length + ' builds');  console.log('Retrieving Build IDs...');  async.map(latestPackages, getBuildID, getRPMList); }function getBuildID(item, cb){  var client = xmlrpc.createClient({ host:  'brewhub.devel.redhat.com', port: 80, path: '/brewhub'});  client.methodCall('getBuild', [item.nvr], function (error,result){    if (! error){      item.build_id = result.id;      item.owner_name = result.owner_name;      cb(null, item);    }    else    {      cb(error, item);    }  }        );}function getRPMList(error, packageList){  console.log('Retrieving list of RPMs');  async.map(packageList, getRPMData, getRPMs);}function getRPMData(item, cb){  var client = xmlrpc.createClient({ host:  'brewhub.devel.redhat.com', port: 80, path: '/brewhub'});   client.methodCall('listRPMs',[{'buildID': item.build_id, '__starstar': 1}], function (error, result){      if (!error){        for (var i=0;i<result.length; i++){          var rpm = result[i];          if (rpm.arch == 'src')          {            item.pkgName = rpm['name'];            item.pkgversion = rpm.version;            item.rpmurl = 'http://download.devel.redhat.com/brewroot/packages/' + rpm['name'] + '/' + rpm.version+ '/' + rpm.release + '/' + rpm.arch + '/' + item.nvr + '.src.rpm';            // Update brew tag metadata cache            brewTag.pkgList.push({pkgName: item.pkgName,               nvr: item.nvr,               rpmurl: item.rpmurl,               build_id: item.build_id,               owner_name: item.owner_name,              pkgVersion: item.pkgVersion});          }        }        cb(null, item);            }       else      {        cb(error, item);      }     }  );}function getRPMs(error, packageList){  var end = new Date().getTime();  var time = end - startTime;  console.log('Execution time: ' + time / 1000 + ' seconds');  console.log('Downloading ' + packageList.length + ' RPM packages. May take some time....');  // Here is where we persist our new or updated brew tag metadata.  // Doesn't take place if we are operating from cached metadata  if (!brewCacheHit)  {    debug('Updating Brew Tag Metadata');    brewTag.save();  }  packagesToDownload = packageList.length;  packagesDownloaded = 0;    async.map(packageList, downloadRPM, function(err, results){reportResults(results)});}// Function to download file using wgetfunction downloadRPM(item, cb) {  var file_url = item.rpmurl;  var rpmfile = new Object();  function downloadCallback(){    packagesDownloaded++;    console.log('(' + packagesDownloaded + '/' + packagesToDownload + ') ' + rpmfile.file_name + ' downloaded to ' + downloadDir);    stripMetadata(item, rpmfile, cb);  }   // extract the file name  rpmfile.file_name = url.parse(file_url).pathname.split('/').pop();  rpmfile.cachefile = cacheDir + '/' + rpmfile.file_name;  rpmfile.cached = fs.existsSync(rpmfile.cachefile);  // If the file is cached and we are running with --cache, we use the cached version  if (rpmfile.cached && program.cache) {       rpmfile.cache_hit = true;       cacheHits++;    packagesDownloaded++;    console.log('(' + packagesDownloaded + '/' + packagesToDownload + ') ' + rpmfile.file_name + ' found in cache ');    q2.push({item: item, rpmfile: rpmfile}, cb);  }  else  {    rpmfile.cache_hit = false;    var wget = 'wget -q -P ' + downloadDir + ' ' + file_url;    debug('Initiated: ' + wget)     // Remove any partial download first    fs.unlink(downloadDir + '/' + rpmfile.file_name, function(){    q.push({command: wget, rpmfilename: rpmfile.file_name}, downloadCallback);});  }}function stripMetadata(item, rpmfile, cb){// Extract the group and description from the rpm spec file using the rpm command  debug('Strip metadata for ' + rpmfile.file_name);  var our_file = downloadDir + '/' + rpmfile.file_name;  // We use the cache file if we are in cache mode and we got a cache hit  if (rpmfile.cache_hit && program.cache) our_file = cacheDir + '/' + rpmfile.file_name;  debug('Scanning file:' + our_file);  child = exec("rpm -qp --queryformat '%{GROUP}' " + our_file ,     function (error, stdout, stderr) {      item.group = stdout;      debug(rpmfile.file_name + ':' + item.group);      if (error !== null) console.log('exec error: ' + error);      child = exec("rpm -qp --queryformat '%{DESCRIPTION}' " + our_file,         function (error, stdout, stderr) {          item['description'] = stdout;          updateCache(item, rpmfile, cb);        }      );    }  );}function reportResults(results){ // console.log(results);  console.log(cacheHits + ' packages from local cache');  console.log(downloads + ' packages downloaded from network');  executionTime();  stripTag(results, saveResults);}function stripTag(results, cb){// We search for tagged packages in our database, and take the current tag off it// This allows for untagging operations in brew// The tag will be re-added to all packages when we do the save    console.log('Untagging existing package records for ' + tag);    PkgMetadata.update({'brewtags.tag':  tag}, {$pull: {brewtags:{tag: tag}}}, false, true);      cb(results);}function updateCache(item, rpmfile, cb){  //Now that we have the metadata we will update the cache  debug('Updating cache for ' + rpmfile.file_name);  // We are updating the local cache if:  // We are in -cache mode and the cache file did not exist  // We are in -updatecache mode  if ((program.cache && !rpmfile.cached) || program.updatecache)  {    // Move rpm file from download to cache    debug('Moving ' + rpmfile.file_name + ' from download to cache');    fs.rename(downloadDir + '/' + rpmfile.file_name, cacheDir + '/' + rpmfile.file_name, function(){if (cb) cb(null, item); });   }  // Otherwise, if we downloaded the rpm rather than pulling it from the cache, we delete it  else   {    if (!rpmfile.cache_hit)    {      debug('Deleting downloaded file');      child = exec("rm " + downloadDir + '/' + rpmfile.file_name ,       function (error, stdout, stderr) {if (cb) cb(null, item);});    }    else    // We pulled the file from the cache, but don't need to delete it or update it    // e.g: --cache with a cache hit     {      if (cb) cb(null, item);    }  }}function saveResults(results){    console.log('Saving package manifest and metadata for ' + tag);  async.forEach(results, saveAction, removeEmptyTags);}function saveAction(doc,cb){    // Now we search the database for the package    // If it exists, update it; otherwise insert it - "upsert" it    PkgMetadata.update({nvr: doc.nvr},         { $set: {            group: doc.group,             owner_name: doc.owner_name,             description: doc.description,            rpmurl: doc.rpmurl,            pkgName: doc.pkgName,            nvr: doc.nvr,            build_id: doc.build_id,            scanDate: startTime            },          $push:             {             brewtags: {tag: tag}            }        }, {multi: false, upsert: true}, function(err, num, raw){err && console.log(err);cb()});}function executionTime(err){  var end = new Date().getTime();  var time = end - startTime;  console.log('Execution time: ' + time / 1000 + ' seconds');}function removeEmptyTags(results, err){  // These are all packages that were untagged from the tag we were scanning  console.log('Removing untagged packages from database');  PkgMetadata.remove({brewtags: []});  executionTime();}